<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,user-scalable=no,minimal-ui">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="Expires" content="-1">
    <meta http-equiv="Cache-Control" content="no-cache">
    <meta http-equiv="Pragma" content="no-cache">
    <meta name="full-screen" content="yes">
    <meta name="x5-fullscreen" content="true">
    <meta name="x5-page-mode" content="app">
    <meta name="browsermode" content="application">
    <meta name="x5-orientation" content="portrait">
    <title>Array</title>
    <link rel="stylesheet" href="../common/css/bootstrap.css">
    <link rel="stylesheet" href="../common/css/font-awesome.css">
    <link rel="stylesheet" href="../common/css/styles/dark.css">
    <link rel="stylesheet" href="css/base.css">

    <script src="../common/js/jquery-2.0.3.js"></script>
    <script src="../common/js/highlight.pack.js"></script>
    <script src="../common/js/clipboard.js"></script>
    <script src="../common/js/bootstrap.js"></script>
    <script type="text/javascript">

        $(function () {

            //添加复制按钮
            $(' <a class=\"code-copy\" title=\"复制到剪切板\"><i class=\"fa fa-copy\"></i></a>').insertBefore("code")


            /***** 复制按钮 开始*******/
            var clipboardSnippets = new Clipboard('.code-copy', {
                'text': function (trigger) {
                    return $(trigger).parents("pre").children("code").html();
                }

            });
            clipboardSnippets.on('success', function (e) {
                e.clearSelection();
                alert("复制成功")
            });
            clipboardSnippets.on('error', function (e) {
                alert("复制失败");

            });
            hljs.initHighlightingOnLoad();

        });


    </script>


</head>
<body>
<h1 style="margin-top: 50px;">JS对象 Array</h1>
<p class="javascript hljs ">
    参考教程：<br/>
    http://www.runoob.com/jsref/jsref-obj-array.html<br/>
    本文访问地址：https://chentong106140.github.io/ES6/less/less%E6%95%99%E7%A8%8B.html
</p>

<h2><a href="#会替换原数组的方法" name="会替换原数组的方法">会替换原数组的方法</a></h2>
<pre class="javascript hljs ">
    1：copyWithin(target,start,end)：选择复制元素，替换选中元素
    2：fill(value,start,end)：选择需要覆盖的元素的索引位置范围，该范围内的元素，覆盖为一个元素

</pre>

<h2><a href="#不会替换原数组的方法-返回改变后的数组" name="不会替换原数组的方法-返回改变后的数组">不会替换原数组的方法-返回改变后的数组</a></h2>
<pre class="javascript hljs ">
    1：concat(arry1,arry2,...)：将多个数组合并到当前数组内
    2:

</pre>


<h2><a href="#concat" name="concat">concat</a></h2>
<pre class="javascript hljs ">
    描述:
    concat() 方法用于连接两个或多个数组。<br/>
    该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
    不会替换原数组

    语法：
    array1.concat(array2,array3,...,arrayX)

    参数：
    array2, array3, ..., arrayX 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。

    返回值：
    Array 对象 返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。


</pre>
<script src="js/array.concat().js"></script>
<pre class="javascript hljs ">
    <code >
            var a1 = [],
                    a2 = ["one","two","three"],
                    a3 = ["four","five","six"];
            var a4 = a1.concat(a2,a3);
            console.log(a4); //Array [ "one", "two", "three", "four", "five", "six" ]
    </code>
</pre>




<h2><a href="#copyWithin" name="copyWithin">copyWithin</a></h2>
<pre class="javascript hljs ">
    描述:
    1:用于在数组选取开始位置与结束位置之间的数据，覆盖到指定位置target.
    2:数组长度并没有增加
    3:copyWithin会将谁调用该方法的对象也被覆盖掉
    4：会替换原数组

    语法:
    array.copyWithin(target, start, lenth)

    返回值：
        修改后的数组


</pre>
    <table class="table table-bordered table-responsive ">
        <thead>
            <tr>
                <td>参数</td>
                <td>描述</td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>target</td>
                <td>必须。从哪个位置开始被覆盖，索引从0开始</td>
            </tr>
            <tr>
                <td>start</td>
                <td>可选。开始被复制的位置，索引从0开始</td>
            </tr>
            <tr>
                <td>lenth</td>
                <td>可选。被赋值的长度</td>
            </tr>
        </tbody>
    </table>
<script src="js/array.copyWithin().js"></script>
<pre class="javascript hljs ">
    <code>
    var a1 = [0,1,2,3,4,5,6,7,8,9];
    var a2 = a1.copyWithin(2,0,4);  //从索引2的位置开始被覆盖，从索引0的位置开始复制，复制长度为4
    console.log(a1);//Array [ 0, 1, 0, 1, 2, 3, 6, 7, 8, 9 ]说明，a1被覆盖了
    console.log(a2);//Array [ 0, 1, 0, 1, 2, 3, 6, 7, 8, 9 ]

    a1 = [0,1,2,3,4,5,6,7,8,9];
    a1.copyWithin(0,0); //从索引0开始被覆盖，从索引0开始复制，复制长度为数组整个长度
    console.log(a1);    // Array [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

    a1 = [0,1,2,3,4,5,6,7,8,9];
    a1.copyWithin(5,0); //从索引5开始被覆盖，从索引0开始复制，复制长度为数组整个长度
    console.log(a1);//Array [ 0, 1, 2, 3, 4, 0, 1, 2, 3, 4 ] ，发现索引5的位置开始被覆盖了，并且数组整个长度length并没有变动

    //总结：
    //先确定需要开始覆盖的位置索引target，然后再确定需要复制的数据的长度start与end.
    //数据覆盖会从target位置开始，具体覆盖的长度根据，选择复制数据的长度，
    //如果数组从target开始到数组最后元素的长度，大于选择复制数据的范围长度，那么被复制的长度就是end的长度。
    //如果数组从target开始到数组最后元素的长度，小于选择复制数据的范围长度，那么从target位置到数组最后的元素，
    // 有多少元素就覆盖多少元素
        </code>
</pre>




<h2><a href="#entries()" name="entries()">entries()</a></h2>
<pre class="javascript hljs ">
    描述：
        entries()返回Iterator对象，用于循环遍历
        不会替换原数组

    语法：
            数组.entries()

    参数：
            无参

    返回值：
        Iterator对象

</pre>
<script src="js/array.entries().js"></script>
<pre class="javascript hljs ">
    <code>
        var a1 = [ "one", "two", "three", "four", "five", "six" ];
        var entries = a1.entries();//返回Interator对象
        while(true)
        {
            var entry = entries.next();
            if(entry.done)break;//done:true代表遍历完成；false:代表还没有遍历完成
            console.log(entry.done,entry.value,entry.value[0],entry.value[1]);
            //value是一个数组，数组内有2个值，第一个值为当前值在原数组内的索引,第二个值为当前值的具体数据
        }
            //false Array [ 0, "one" ] 0 one
            //false Array [ 1, "two" ] 1 two
            //false Array [ 2, "three" ] 2 three
            //false Array [ 3, "four" ] 3 four
            //false Array [ 4, "five" ] 4 five
            //false Array [ 5, "six" ] 5 six
    </code>
</pre>



<h2><a href="#every()" name="every()">every()</a></h2>
<pre class="javascript hljs ">
    描述：
        every() 方法用于检测数组内每一个元素是否符合指定条件
        1：如果数组内有一个元素不符合条件，整个表达式就返回false,且剩余的元素不会再检测
        2：如果数组内所有元素都符合条件，整个表达式就返回true
        3：every() 不会检测空数组
        4：every() 不会改变原数组
        5：如果不传递thisValue参数，回调函数内的this默认为undefined

    语法：
    array.every(function(currentValue,index,arr), thisValue)

   参数：
    function(currentValue,index,arr)
        currentValue：当前遍历的值
        index：当前遍历值的索引
        arr：当前遍历的值所属的数组对象

    thisValue：用于改变回调函数内this对象的值,如果不传递thisValue参数，回调函数内的this默认为undefined

    返回值：
        Boolean
        不会替换原数组

</pre>
<script src="js/array.every().js"></script>
<pre class="javascript hljs ">
    <code>
    //用于演示替换回调函数内的this值
    var obj = [1,2,3,4,5];

    var a = [11,22,33,44,55,66,77];
    var b = a.every(function(num,index,array){
        console.log(num,index,array,this);
        return num > 10;
    },obj);
    //输出：
    //11   0   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //22   1   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //33   2   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //44   3   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //55   4   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //66   5   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    //77   6   Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    console.log(b); //true
    //总结：
    // 如果数组内所有的元素都符合指定要求，那么数组的每一个元素都会遍历到，同时every()方法会返回true
    //通过输出结果可以看出，传递了obj对象，就会替换回调函数内的this对象
    //回调函数内的3个参数分别为：当前遍历的元素，当前元素的索引，当前遍历的数组



    var c = a.every(function(num,index,array){
        console.log(num,index,array,this);
        return num > 30;
    },obj);
    //输出：
    //11 0     Array [ 11, 22, 33, 44, 55, 66, 77 ]    Array [ 1, 2, 3, 4, 5 ]
    console.log(c);//false
    //总结：如果数组内只要有一个元素不符合指定要求，那么之后的所有元素都不会继续遍历,同时every()方法会返回false
        </code>
</pre>
<h2><a href="#fill()" name="fill()">fill()</a></h2>
<pre class="javascript hljs ">
    描述：
        fill()用于将一个固定值，替换数组内指定范围的所有元素。

    语法：
        array.fill(value, start, end)

    参数：
        value：必须，需要填充的值
        start：可选，开始替换的索引位置，从0开始
        end：  可选，替换的长度，默认为数组的length长度

    返回值：
        会替换原数组

</pre>
<script src="js/array.fill().js"></script>
<pre class="javascript hljs ">
    <code>
    var a = [0,1,2,3,4,5,6,7,8,9];
    var b = a.fill(100);
    console.log(a);//Array [ 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 ]
    console.log(b);//Array [ 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 ]
    //总结：
    //1：fill()方法会替换原数组
    //2：如果只传递一个参数，没有指定替换范围，默认会替换数组内所有的元素



    var a = [0,1,2,3,4,5,6,7,8,9];
    var b = a.fill(100,5);
    console.log(a);//Array [ 0, 1, 2, 3, 4, 100, 100, 100, 100, 100 ]
    console.log(b);//Array [ 0, 1, 2, 3, 4, 100, 100, 100, 100, 100 ]
    //总结：
    //1：传递了二个参数，指定了开始替换的索引位置，那么就从该位置开始替换，并且将该位置后面所有的元素都替换


    var a = [0,1,2,3,4,5,6,7,8,9];
    var b = a.fill(100,5,7);
    console.log(a);//Array [ 0, 1, 2, 3, 4, 100, 100, 7, 8, 9 ]
    console.log(b);//Array [ 0, 1, 2, 3, 4, 100, 100, 7, 8, 9 ]
    //总结：
    //1：传递了三个参数，指定了覆盖的元素，同时也指定了被覆盖元素的所以起点位置从0开始，到被覆盖元素的终点位置（从1开始）
    //2：切记，如果终点的索引位置的值，小于，开始位置索引位置的值，就不起作用，也就是什么都不替换

    var a = [0,1,2,3,4,5,6,7,8,9];
    var b = a.fill(100,5,4);
    console.log(a);//Array [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    console.log(b);//Array [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    //总结：
    //1：如上效果，终点的索引位置从1开始的值，小于起点位置从0开始的值，就会不起作用
    </code>
</pre>
<h2><a href="#filter()" name="filter()">filter()</a></h2>
<pre class="javascript hljs ">
    描述：
        1： filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
        2： filter() 不会对空数组进行检测。
        3： filter() 不会改变原始数组。

    语法：
        array.filter(function(currentValue,index,arr), thisValue)

   参数：
    function(currentValue,index,arr)
        currentValue：当前遍历的值
        index：当前遍历值的索引
        arr：当前遍历的值所属的数组对象

    thisValue：用于改变回调函数内this对象的值,如果不传递thisValue参数，回调函数内的this默认为undefined

    返回值：
        1：返回所有符合回调函数内指定条件的所有元素，为一个数组
        2：如果没有符合条件的元素，返回一个空数组

    总结：
        与every()方法的区别:
        1:every()方法有符合条件的返回true，没有符合条件的返回false
        2:filter()方法有符合条件的返回符合条件的元素组装为一个新数组返回，没有符合条件的返回空数组
        3:every()方法有符合条件的遍历所有元素，没有符合条件的就不再遍历
        4:filter()方法无论是否有符合条件的元素，都会遍历所有元素

        与every()方法的共同点：
        1：参数都一样
        2：都不修改原数组
        3：回调函数内都是返回的true/false，来判定是否符合指定条件

</pre>
<script src="js/array.filter().js"></script>

</body>
</html>